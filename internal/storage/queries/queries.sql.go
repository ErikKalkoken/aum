// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package queries

import (
	"context"
)

const countApplicationByID = `-- name: CountApplicationByID :one
SELECT
  count(*)
FROM
  applications
WHERE
  app_id = ?
`

func (q *Queries) CountApplicationByID(ctx context.Context, appID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countApplicationByID, appID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReport = `-- name: CreateReport :exec
INSERT INTO
  reports (app_id, arch, machine_id, os, version)
VALUES
  (?, ?, ?, ?, ?)
`

type CreateReportParams struct {
	AppID     string
	Arch      string
	MachineID string
	Os        string
	Version   string
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) error {
	_, err := q.db.ExecContext(ctx, createReport,
		arg.AppID,
		arg.Arch,
		arg.MachineID,
		arg.Os,
		arg.Version,
	)
	return err
}

const listApplicationPlatforms = `-- name: ListApplicationPlatforms :many
SELECT
  platform, COUNT(platform)
FROM
  reports_platforms
WHERE
  app_id = ?
GROUP BY
  platform
`

type ListApplicationPlatformsRow struct {
	Platform interface{}
	Count    int64
}

func (q *Queries) ListApplicationPlatforms(ctx context.Context, appID string) ([]ListApplicationPlatformsRow, error) {
	rows, err := q.db.QueryContext(ctx, listApplicationPlatforms, appID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApplicationPlatformsRow
	for rows.Next() {
		var i ListApplicationPlatformsRow
		if err := rows.Scan(&i.Platform, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApplicationsWithMetric = `-- name: ListApplicationsWithMetric :many
SELECT
  ap.app_id, ap.name,
  COUNT(DISTINCT(rp.machine_id)) as user_count,
  MAX(rp.timestamp) as latest
FROM
  applications ap
  JOIN reports rp ON rp.app_id = ap.app_id
GROUP BY
  ap.app_id
ORDER BY
  ap.name
`

type ListApplicationsWithMetricRow struct {
	Application Application
	UserCount   int64
	Latest      interface{}
}

func (q *Queries) ListApplicationsWithMetric(ctx context.Context) ([]ListApplicationsWithMetricRow, error) {
	rows, err := q.db.QueryContext(ctx, listApplicationsWithMetric)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListApplicationsWithMetricRow
	for rows.Next() {
		var i ListApplicationsWithMetricRow
		if err := rows.Scan(
			&i.Application.AppID,
			&i.Application.Name,
			&i.UserCount,
			&i.Latest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrCreateApplication = `-- name: UpdateOrCreateApplication :exec
INSERT INTO
  applications (app_id, name)
VALUES
  (?1, ?2) ON CONFLICT(app_id) DO
UPDATE
SET
  name = ?2
WHERE
  app_id = ?1
`

type UpdateOrCreateApplicationParams struct {
	AppID string
	Name  string
}

func (q *Queries) UpdateOrCreateApplication(ctx context.Context, arg UpdateOrCreateApplicationParams) error {
	_, err := q.db.ExecContext(ctx, updateOrCreateApplication, arg.AppID, arg.Name)
	return err
}
